# 1 对象存活算法
## 1.1 引用计数算法
给对象添加一个引用计数器，当对象被其他对象引用时，改计数器+1，当引用关系失效时，计数器-1，当计数器为0时，可认为该对象可被回收  
该算法实现简单，但是无法处理循环引用的问题
## 1.2 可达性分析算法
该算法以GC ROOT对象作为根节点，遍历引用关系树，当对象与GC ROOT对象有路径（称之为引用链）可达时，认为该对象存活，反之认为该对象可被回收  
在JVM内，GC ROOT对象分为以下几种:  
1. 虚拟机栈中本地变量表引用的对象
2. 本地方法栈内引用的对象
3. 元数据区静态属性引用的对象
4. 常量引用的对象
## 1.3 引用类别
1. 强引用: 最强的引用关系，只要与GC ROOT存在该引用关系，对象即不会被回收
2. 软引用：次之的引用关系，仅当有内存溢出分险时，改引用关系修饰的对象才会被允许回收
3. 弱引用：再次之的引用关系，当GC时，该对象就会被回收
4. 虚引用：最弱的引用关系，甚至无法通过该引用关系获取对象实例。当存在该引用关系的对象被回收时，会触发回调一个系统通知
# 2 垃圾收集算法
## 2.1 标记清除算法
该算法分为标记和清除两步，先通过对象存活算法标记可回收的对象，标记完成后统一回收所有被标记的对象以释放内存。  
该算法缺点主要会产生大量的内存碎片，导致分配大对象时，无法获得足够大的内存区段从而再次触发GC
## 2.2 复制算法
该算法将内存划为大小相等的两块，过程主要分别为标记、复制、清除三步。其先通过对象存活算法获取存活的对象，再将存活的对象同意复制到
另外一块内存上，最后清空原先空间的对象。  
该算法虽然避免了内存碎片，但是却浪费了一块内存空间
## 2.3 标记整理算法
为了解决标记清理算法产生内存碎片的问题，该算法不在直接清理为存活的对象，而是先将存活的对象向一端移动，然后清理边界之外的对象
## 2.4 分代收集算法
考虑到不同对象的存活周期不同，所以JVM内存被划为不同的区，并采用不同的收集算法进行垃圾回收，
比如年轻代使用复制算法，老年代使用标记清理或者标记整理算法
# 3 垃圾收集器
垃圾收集器主要分为Serial收集器、ParNew收集器、Parallel Scavenge收集器、Serial Old收集器、Parallel Old收集器、CMS收集器、G1收集器
## 3.1 Serial收集器
最基础的收集器，单线程工作，当进行垃圾收集时，必须要等待应用的工作线程都进入安全点或者安全区域后，暂停所有工作线程的工作即STW（Stop The World），
才能开始垃圾清理
## 3.2 ParNew收集器
Serial的多线程版本
## 3.3 Parallel Scavenge收集器
使用复制算法的多线程并行的吞吐量优先的收集器。相比较其他收集器，其目标在于达到一个指定的吞吐量（吞吐量=运行用户的代码时间/（GC时间+运行用户的代码时间)),
并且其提供GC自适应的调节策略
## 3.4 Serial Old收集器
Serial收集器的老年代版本
## 3.5 Parallel Old收集器
Parallel Scavenge收集器的老年代版本
## 3.6 CMS收集器
该收集器旨在以获取最短回收停顿时间为目标的收集器。其采用标记清除算法，主要为四个步骤：
1. 初始标记：需要STW，仅标记GC ROOT直接关联到的对象
2. 并发标记：不需要STW，根据初始标记的对象并发进行遍历，标记在引用链上的对象
3. 重新标记：需要STW，用于修正在并发标记途中用户程序并发执行导致引用链发生变化的对象的标记
4. 并发清除：不需要STW，并发清除未标记的对象
该收集器虽然有着并发收集，低停顿的优点，但是其无法处理浮动垃圾即在标记过程新产生的垃圾，并且因为基于标记清除算法，所以会产生内存碎片
## 3.7 G1收集器
### 3.7.1 特点  
1. 并行和并发：其可利用多核并行收集，同时在部分原先需要停顿的GC动作现在可以和用户工作线程并发执行
2. 分代收集：其虽然能独立管理整个堆，但是其针对不同状态的对象可采用不同的方式进行处理
3. 空间整合：其整体遵循标记整理算法，故可以防止空间碎片
4. 可预测的停顿：其可以建立可预测的停顿时间模型，从而可控制在一个时间段内消耗的垃圾收集时间
### 3.7.2 内存模型
当采用该收集器时，堆的内存布局不同于其他收集器，其被分割为多个大小相等的内存区块（Region），同时每个内存区块皆配有一个Remembered Set以记录该区
对象被其他区块对象引用的情况，避免GC时进行全堆扫描。同时年轻代和老年代都是一部分内存区块的集合  
在JVM运行时，G1跟踪各个内存区块的垃圾回收的价值情况，形成一个优先列表，当每次GC时，根据收集时间的限制，回收价值最高的区块。
### 3.7.3 收集流程
1. 初始标记：需要STW，仅标记GC ROOT直接关联到的对象
2. 并发标记：不需要STW，根据初始标记的对象并发进行遍历，标记在引用链上的对象
3. 最终标记：需要STW，用于修正在并发标记途中用户程序并发执行导致引用链发生变化的对象的标记。因为并行标记时对象的变化会被记录至
Remembered Set Logs内，并且在该阶段会和Remembered Set进行合并，所以也不需要全堆扫描
4. 筛选回收：根据回收时间限制，回收价值最高的内存区块
## 3.8 配合使用
|  年轻代   | 老年代  |
|  ----    | ----  |
| Serial   | CMS、Serial Old |
| ParNew   | CMS、Serial Old |
| Parallel | Scavenge SerialOld、Parallel Old |
| G1       | G1 |
