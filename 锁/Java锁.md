# 1 Synchronized关键词
## 1.1 使用方式
1. 修饰静态方法：此时锁住的是类对象，非实例对象，故当A线程调用一个类的同步静态方法时，B线程可同时调用改类的实例对象的同步实例方法
2. 修饰实例方法：作用于当前对象实例，执行该方法需要获取当前对象实例的锁
3. 修饰代码块：与修饰实例方法类似，其根本还是锁住一个对象
## 1.2 原理
主要是由JVM来实现，当进入同步代码块或同步方法时，线程会尝试获取对应对象的对象头的monitor对象，若获取到，代表持有了该对象锁，从而执行代码，
反之则阻塞等待
## 1.3 JDK1.6后的优化
JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。  
目前对于锁，JVM会根据锁竞争情况，将锁从无锁态升级为偏向锁、轻量级锁、重量级锁,且只能升级，不可降级。
### 1.3.1 偏向锁
在无竞争的情况下，JVM仅会将线程号记录于对象头上，标志其获得了偏向锁，并在之后再次调用该同步块时对比线程号，一致则不作操作继续执行代码，
反之，则确认记录的线程号对应的线程是否存活且是否需要使用锁，若是存活且需要锁，则升级为轻量级锁，反之将当前请求的线程号覆盖之前的线程号，继续维持偏向锁状态。
### 1.3.2 轻量级锁
从偏向锁升级到该状态时，不同于重量级锁的信号量机制，此锁依赖于CAS操作，CAS成功者意味着获得锁开始执行代码，而其他线程则自旋等待。
若线程自旋次数过多，或有更多线程需求锁，此时锁会再度膨胀，变为重量级锁，自旋的线程将被挂起
### 1.3.3 重量级锁
等级最高的锁状态，基于信号量互斥操作的锁
### 1.3.4 自旋锁和适应性自旋锁
自旋锁主要是在无法获取锁的情况下，不被挂起，而是自身循环查询锁是否被释放，在锁被占用时间较短的情况下，该行为相比于挂起唤醒操作更加节省资源，
反之则浪费CPU时间。  
适应性自旋锁的自旋次数不在固定，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定
### 锁消除
若运行中，JVM检测到共享资源不存在竞争的情况下，会消除请求锁的操作
### 锁粗化
若运行中，JVM检测到一连串的加锁解锁操作过多时，会将这一系列的锁合并扩展成一个范围更大的锁，从而减少加锁解锁的次数
# 2 ReentrantLock